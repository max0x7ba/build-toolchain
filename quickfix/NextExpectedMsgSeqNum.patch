Only in quickfix: build.sh
Only in quickfix: .git
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/Session.cpp quickfix/src/C++/Session.cpp
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/Session.cpp	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/Session.cpp	2015-09-29 14:44:46.427223512 +0000
@@ -43,7 +43,8 @@
                   const SessionID& sessionID,
                   const DataDictionaryProvider& dataDictionaryProvider,
                   const TimeRange& sessionTime,
-                  int heartBtInt, LogFactory* pLogFactory )
+                  int heartBtInt, LogFactory* pLogFactory,
+                  bool useExternalScheduler )
 : m_application( application ),
   m_sessionID( sessionID ),
   m_sessionTime( sessionTime ),
@@ -61,6 +62,10 @@
   m_millisecondsInTimeStamp( true ),
   m_persistMessages( true ),
   m_validateLengthAndChecksum( true ),
+  m_enableExpectedNext( false ),
+  m_ignoreStartEndDayTime( false ),
+  m_isOpen( true ),
+  m_useExternalScheduler( useExternalScheduler ),
   m_dataDictionaryProvider( dataDictionaryProvider ),
   m_messageStoreFactory( messageStoreFactory ),
   m_pLogFactory( pLogFactory ),
@@ -77,8 +82,15 @@
 
   addSession( *this );
   m_application.onCreate( m_sessionID );
+  if (m_useExternalScheduler)
+  {
+    m_state.onEvent( "Created session with external scheduling" );
+  }
+  else
+  {
   m_state.onEvent( "Created session" );
 }
+}
 
 Session::~Session()
 {
@@ -133,6 +145,8 @@
   {
     if ( !checkSessionTime(timeStamp) )
       { reset(); return; }
+    if ( !isOpen() )
+      { generateLogout(); disconnect(); return; }
 
     if( !isEnabled() || !isLogonTime(timeStamp) )
     {
@@ -247,13 +261,71 @@
     return;
   m_state.receivedLogon( true );
 
+  MsgSeqNum msgSeqNum;
+  logon.getHeader().getField( msgSeqNum );
+
+  // remember the expected sender sequence number of any logon response for future use
+  int nextSenderMsgNumAtLogonReceived = m_state.store()->getNextSenderMsgSeqNum();
+
+  /**
+   * We test here that its not too high (which would result in a resend) and that we are not
+   * resetting on logon 34=1
+   */
+  bool isLogonInNormalSequence = !( isTargetTooHigh( msgSeqNum ) && !resetSeqNumFlag );
+
+  // if we have a tag 789 sent to us  ...
+  const bool nextExpectedMsgSeqNumSet = logon.isSetField(FIELD::NextExpectedMsgSeqNum);
+  if ( nextExpectedMsgSeqNumSet && getEnableExpectedNextMsgSeqNumOnLogon() )
+  {
+      NextExpectedMsgSeqNum targetWantsNextSeqNumToBe;
+      logon.getField(targetWantsNextSeqNumToBe);
+
+      int actualNextNum = m_state.store()->getNextSenderMsgSeqNum();
+
+      // Is the 789 we received too high ??
+      if ( targetWantsNextSeqNumToBe > actualNextNum )
+      {
+          // We can't resend what we never sent! something undiscoverable has happened
+          std::stringstream err;
+          err << "Tag "
+              << FIELD::NextExpectedMsgSeqNum
+              << "(NextExpectedMsgSeqNum) is higher than the next-to-be-assigned sequence number. Expected "
+              << actualNextNum
+              << ". Received "
+              << targetWantsNextSeqNumToBe;
+          m_state.onEvent( err.str() );
+          generateLogout( err.str() );
+          disconnect();
+          return;
+      }
+  }
+
   if ( !m_state.initiate() 
        || (m_state.receivedReset() && !m_state.sentReset()) )
   {
+      /**
+       * If we got one too high they need messages resent use the first message they missed (as we gap fill with that).
+       * If we reset on logon, the current value will be 1 and we always send (we haven't inc'd for current message yet +1) 2
+       * If happy path (we haven't inc'd for current message yet so its current +1)
+       */
+      int nextExpectedTargetNum = m_state.store()->getNextTargetMsgSeqNum();
+      // we increment for the logon later (after logon response sent) in this method if and only if in sequence so ..
+      if ( isLogonInNormalSequence )
+      {
+          nextExpectedTargetNum++;
+      }
+
     logon.getFieldIfSet(m_state.heartBtInt());
     m_state.onEvent( "Received logon request" );
     generateLogon( logon );
-    m_state.onEvent( "Responding to logon request" );
+      
+      std::stringstream msg;
+      msg << "Responding to logon request";
+      if ( nextExpectedMsgSeqNumSet )
+      {
+          msg << " 789=" << nextExpectedTargetNum;
+      }
+      m_state.onEvent( msg.str() );
   }
   else
     m_state.onEvent( "Received logon response" );
@@ -261,10 +333,18 @@
   m_state.sentReset( false );
   m_state.receivedReset( false );
 
-  MsgSeqNum msgSeqNum;
-  logon.getHeader().getField( msgSeqNum );
-  if ( isTargetTooHigh( msgSeqNum ) && !resetSeqNumFlag )
+  // Looking at the sequence number of the incoming logon, is it too high indicating possible missed messages ? ..
+  if ( !isLogonInNormalSequence )
+  {
+    // if 789 was sent then we effectively have already send a resend request
+    if ( m_state.expectedLogonNextSeqNumSent() )
   {
+      // mark state as if we have already sent a resend request from the logon's 789 (we sent) to infinity
+      m_state.setResetRangeFromLastExpectedLogonNextSeqNumLogon();
+
+      // This will suppress the resend request in doTargetTooHigh ....
+      m_state.onEvent( "Required resend will be suppressed as we're setting 789" );
+    }
     doTargetTooHigh( logon );
   }
   else
@@ -273,10 +353,126 @@
     nextQueued( timeStamp );
   }
 
+  // do we have a 789
+  if ( logon.isSetField( FIELD::NextExpectedMsgSeqNum ) && getEnableExpectedNextMsgSeqNumOnLogon() )
+  {
+    NextExpectedMsgSeqNum targetWantsNextSeqNumToBe;
+    logon.getField( targetWantsNextSeqNumToBe );
+    int actualNextNum = nextSenderMsgNumAtLogonReceived;
+
+    // is the 789 lower (we checked for higher previously) thna our next message after receiving the logon
+    if ( targetWantsNextSeqNumToBe != actualNextNum )
+    {
+      int endSeqNo = actualNextNum;
+
+      // Just do a gap fill when messages aren't persisted
+      std::stringstream msg;
+      msg << "Received implicit ResendRequest via Logon FROM: "
+          << targetWantsNextSeqNumToBe
+          << " TO: "
+          << actualNextNum;
+      if ( !m_persistMessages )
+      {
+        endSeqNo += 1;
+        int next = m_state.getNextSenderMsgSeqNum();
+        if ( endSeqNo > next )
+          endSeqNo = next;
+
+        msg << " will reset";
+        m_state.onEvent( msg.str() );
+        generateSequenceReset( targetWantsNextSeqNumToBe, endSeqNo );
+      }
+      else // replay messages
+      {
+        // resend missed messages
+        msg << " will replay";
+        m_state.onEvent( msg.str() );
+        replayMessages( targetWantsNextSeqNumToBe, endSeqNo );
+      }
+    } // end of 789 indicates missing messages at other side
+  } // end of if we have a tag 789
+
   if ( isLoggedOn() )
     m_application.onLogon( m_sessionID );
 }
 
+void Session::replayMessages( int beginSeqNo, int endSeqNo )
+{
+  std::vector < std::string > messages;
+  m_state.get( beginSeqNo, endSeqNo, messages );
+
+  std::vector < std::string > ::iterator i;
+  MsgSeqNum msgSeqNum(0);
+  MsgType msgType;
+  int begin = 0;
+  int current = beginSeqNo;
+  std::string messageString;
+  Message msg;
+
+  for ( i = messages.begin(); i != messages.end(); ++i )
+  {
+    const DataDictionary& sessionDD =
+      m_dataDictionaryProvider.getSessionDataDictionary(m_sessionID.getBeginString());
+
+    if( m_sessionID.isFIXT() )
+    {
+      msg.setStringHeader(*i);
+      ApplVerID applVerID;
+      if( msg.getHeader().isSetField(applVerID) )
+        msg.getHeader().getField(applVerID);
+      else
+        applVerID = m_senderDefaultApplVerID;
+
+      const DataDictionary& applicationDD =
+        m_dataDictionaryProvider.getApplicationDataDictionary(applVerID);
+      msg = Message( *i, sessionDD, applicationDD );
+    }
+    else
+    {
+      msg = Message( *i, sessionDD );
+    }
+
+
+    msg.getHeader().getField( msgSeqNum );
+    msg.getHeader().getField( msgType );
+
+    if( (current != msgSeqNum) && !begin )
+      begin = current;
+
+    if ( Message::isAdminMsgType( msgType ) )
+    {
+      if ( !begin ) begin = msgSeqNum;
+    }
+    else
+    {
+      if ( resend( msg ) )
+      {
+        if ( begin ) generateSequenceReset( begin, msgSeqNum );
+        send( msg.toString(messageString) );
+        m_state.onEvent( "Resending Message: "
+                         + IntConvertor::convert( msgSeqNum ) );
+        begin = 0;
+      }
+      else
+      { if ( !begin ) begin = msgSeqNum; }
+    }
+    current = msgSeqNum + 1;
+  }
+  if ( begin )
+  {
+    generateSequenceReset( begin, msgSeqNum + 1 );
+  }
+
+  if ( endSeqNo > msgSeqNum )
+  {
+    endSeqNo = EndSeqNo(endSeqNo + 1);
+    int next = m_state.getNextSenderMsgSeqNum();
+    if( endSeqNo > next )
+      endSeqNo = EndSeqNo(next);
+    generateSequenceReset( beginSeqNo, endSeqNo );
+  }
+}
+
 void Session::nextHeartbeat( const Message& heartbeat, const UtcTimeStamp& timeStamp )
 {
   if ( !verify( heartbeat ) ) return ;
@@ -369,9 +565,10 @@
     if( endSeqNo > next )
       endSeqNo = EndSeqNo(next);
     generateSequenceReset( beginSeqNo, endSeqNo );
-    return;
+    //return;
   }
-
+  else
+  {
   std::vector < std::string > messages;
   m_state.get( beginSeqNo, endSeqNo, messages );
 
@@ -443,7 +640,9 @@
       endSeqNo = EndSeqNo(next);
     generateSequenceReset( beginSeqNo, endSeqNo );
   }
+  }
 
+  MsgSeqNum msgSeqNum(0);
   resendRequest.getHeader().getField( msgSeqNum );
   if( !isTargetTooHigh(msgSeqNum) && !isTargetTooLow(msgSeqNum) )
     m_state.incrNextTargetMsgSeqNum();
@@ -619,10 +818,19 @@
   m_state.lastReceivedTime( now );
   m_state.testRequest( 0 );
   m_state.sentLogon( true );
+
+  // we have enabled 789 support change
+  if ( getEnableExpectedNextMsgSeqNumOnLogon() )
+  {
+      NextExpectedMsgSeqNum nextExpectedMsgNum( getExpectedTargetNum() );
+      logon.setField( nextExpectedMsgNum );
+      m_state.setLastExpectedLogonNextSeqNum( nextExpectedMsgNum );
+  }
+
   sendRaw( logon );
 }
 
-void Session::generateLogon( const Message& aLogon )
+void Session::generateLogon( const Message& aLogon,  int expectedTargetNum )
 {
   Message logon;
   EncryptMethod encryptMethod;
@@ -636,6 +844,14 @@
   logon.getHeader().setField( MsgType( "A" ) );
   logon.setField( heartBtInt );
   fill( logon.getHeader() );
+
+    if ( getEnableExpectedNextMsgSeqNumOnLogon() )
+    {
+        NextExpectedMsgSeqNum nextExpectedMsgSeqNum( expectedTargetNum );
+        logon.setField( nextExpectedMsgSeqNum );
+        m_state.setLastExpectedLogonNextSeqNum( expectedTargetNum );
+    }
+
   sendRaw( logon );
   m_state.sentLogon( true );
 }
@@ -1213,6 +1429,8 @@
   {
     if ( !checkSessionTime(timeStamp) )
       { reset(); return; }
+        if ( !isOpen() )
+          { generateLogout(); disconnect(); return; }
 
     const MsgType& msgType = FIELD_GET_REF( header, MsgType );
     const BeginString& beginString = FIELD_GET_REF( header, BeginString );
@@ -1484,4 +1702,22 @@
   s_sessionIDs.erase( s.m_sessionID );
   s_registered.erase( s.m_sessionID );
 }
+
+bool Session::isOpen() const
+{
+  Locker locker( m_mutex );
+  return m_isOpen;
+
+}
+
+bool Session::setOpen( bool value )
+{
+  bool currentValue;
+  Locker locker( m_mutex );
+  currentValue = m_isOpen;
+  m_isOpen = value;
+
+  return currentValue;
+}
+
 }
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/SessionFactory.cpp quickfix/src/C++/SessionFactory.cpp
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/SessionFactory.cpp	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/SessionFactory.cpp	2015-09-29 14:44:46.428223567 +0000
@@ -75,12 +75,22 @@
     }
   }
 
+  bool useExternalScheduler = false;
+  if ( settings.has(USE_EXTERNAL_SCHEDULER) )
+  {
+    useExternalScheduler = settings.getBool( USE_EXTERNAL_SCHEDULER );
+  }
+
+  UtcTimeOnly startTime;
+  UtcTimeOnly endTime;
+  int startDay = -1;
+  int endDay = -1;
   bool useLocalTime = false;
+  if (!useExternalScheduler)
+  {
   if( settings.has(USE_LOCAL_TIME) )
     useLocalTime = settings.getBool( USE_LOCAL_TIME );
 
-  int startDay = -1;
-  int endDay = -1;
   try
   {
     startDay = settings.getDay( START_DAY );
@@ -89,8 +99,6 @@
   catch( ConfigError & ) {}
   catch( FieldConvertError & e ) { throw ConfigError( e.what() ); }
 
-  UtcTimeOnly startTime;
-  UtcTimeOnly endTime;
   try
   {
     startTime = UtcTimeOnlyConvertor::convert
@@ -99,6 +107,17 @@
               ( settings.getString( END_TIME ) );
   }
   catch ( FieldConvertError & e ) { throw ConfigError( e.what() ); }
+  }
+  else
+  {
+    startTime = UtcTimeOnly(0,0,0);
+    endTime = UtcTimeOnly(0,0,0);
+  }
+
+  if( startDay >= 0 && endDay < 0 )
+    throw ConfigError( "StartDay used without EndDay" );
+  if( endDay >= 0 && startDay < 0 )
+    throw ConfigError( "EndDay used without StartDay" );
 
   TimeRange utcSessionTime
     ( startTime, endTime, startDay, endDay );
@@ -108,11 +127,6 @@
       startDay, endDay );
   TimeRange sessionTimeRange = useLocalTime ? localSessionTime : utcSessionTime;
 
-  if( startDay >= 0 && endDay < 0 )
-    throw ConfigError( "StartDay used without EndDay" );
-  if( endDay >= 0 && startDay < 0 )
-    throw ConfigError( "EndDay used without StartDay" );
-
   HeartBtInt heartBtInt( 0 );
   if ( connectionType == "initiator" )
   {
@@ -123,7 +137,8 @@
   std::auto_ptr<Session> pSession;
   pSession.reset( new Session( m_application, m_messageStoreFactory,
     sessionID, dataDictionaryProvider, sessionTimeRange,
-    heartBtInt, m_pLogFactory ) );
+    heartBtInt, m_pLogFactory,
+    useExternalScheduler ) );
 
   pSession->setSenderDefaultApplVerID(defaultApplVerID);
 
@@ -192,8 +207,12 @@
     pSession->setMillisecondsInTimeStamp( settings.getBool( MILLISECONDS_IN_TIMESTAMP ) );
   if ( settings.has( PERSIST_MESSAGES ) )
     pSession->setPersistMessages( settings.getBool( PERSIST_MESSAGES ) );
+  if ( settings.has( ENABLE_EXPECTED_NEXT_SEQ_NUM_ON_LOGON ) )
+    pSession->setEnableExpectedNextMsgSeqNumOnLogon( settings.getBool( ENABLE_EXPECTED_NEXT_SEQ_NUM_ON_LOGON ) );
   if ( settings.has( VALIDATE_LENGTH_AND_CHECKSUM ) )
     pSession->setValidateLengthAndChecksum( settings.getBool( VALIDATE_LENGTH_AND_CHECKSUM ) );
+  if ( settings.has( IGNORE_START_END_DAY_TIME ) )
+    pSession->setIgnoreStartEndDayTime( settings.getBool( IGNORE_START_END_DAY_TIME ) );
    
   return pSession.release();
 }
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/Session.h quickfix/src/C++/Session.h
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/Session.h	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/Session.h	2015-09-29 14:44:46.427223512 +0000
@@ -49,7 +49,8 @@
            const SessionID&,
            const DataDictionaryProvider&,
            const TimeRange&,
-           int heartBtInt, LogFactory* pLogFactory );
+           int heartBtInt, LogFactory* pLogFactory,
+           bool useExternalScheduler = false );
   virtual ~Session();
 
   void logon() 
@@ -105,8 +106,11 @@
 
   static size_t numSessions();
 
+  bool isOpen() const;
+  bool setOpen( bool value );
+
   bool isSessionTime(const UtcTimeStamp& time)
-    { return m_sessionTime.isInRange(time); }
+    { if ( m_ignoreStartEndDayTime ) return m_sessionTime.isInRange(time) && isOpen(); else return isOpen(); }
   bool isLogonTime(const UtcTimeStamp& time)
     { return m_logonTime.isInRange(time); }
   bool isInitiator()
@@ -189,6 +193,16 @@
   void setPersistMessages ( bool value )
     { m_persistMessages = value; }
 
+  bool getEnableExpectedNextMsgSeqNumOnLogon()
+    { return m_enableExpectedNext; }
+  void setEnableExpectedNextMsgSeqNumOnLogon ( bool value )
+    { m_enableExpectedNext = value; }
+
+  bool getIgnoreStartEndDayTime() const
+    { return m_ignoreStartEndDayTime; }
+  void setIgnoreStartEndDayTime( bool value )
+    { m_ignoreStartEndDayTime = value; }
+
   bool getValidateLengthAndChecksum()
     { return m_validateLengthAndChecksum; }
   void setValidateLengthAndChecksum ( bool value )
@@ -239,6 +253,9 @@
   }
   bool checkSessionTime( const UtcTimeStamp& timeStamp )
   {
+    // If we use external scheduler, we rely on session m_open
+    // and reset() is called by the external scheduler
+    if (m_useExternalScheduler) return true;
     UtcTimeStamp creationTime = m_state.getCreationTime();
     return m_sessionTime.isInSameRange( timeStamp, creationTime );
   }
@@ -278,7 +295,7 @@
   void nextResendRequest( const Message&, const UtcTimeStamp& timeStamp );
 
   void generateLogon();
-  void generateLogon( const Message& );
+  void generateLogon( const Message&, int expectedTargetNum = 0 );
   void generateResendRequest( const BeginString&, const MsgSeqNum& );
   void generateSequenceReset( int, int );
   void generateHeartbeat();
@@ -298,6 +315,8 @@
   bool set( int s, const Message& m );
   bool get( int s, Message& m ) const;
 
+  void replayMessages( int beginSeqNo, int endSeqNo );
+
   Application& m_application;
   SessionID m_sessionID;
   TimeRange m_sessionTime;
@@ -316,13 +335,17 @@
   bool m_millisecondsInTimeStamp;
   bool m_persistMessages;
   bool m_validateLengthAndChecksum;
+  bool m_enableExpectedNext;
+  bool m_ignoreStartEndDayTime;
+  bool m_isOpen;
+  bool m_useExternalScheduler;
 
   SessionState m_state;
   DataDictionaryProvider m_dataDictionaryProvider;
   MessageStoreFactory& m_messageStoreFactory;
   LogFactory* m_pLogFactory;
   Responder* m_pResponder;
-  Mutex m_mutex;
+  mutable Mutex m_mutex;
 
   static Sessions s_sessions;
   static SessionIDs s_sessionIDs;
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/SessionSettings.h quickfix/src/C++/SessionSettings.h
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/SessionSettings.h	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/SessionSettings.h	2015-09-29 14:44:46.428223567 +0000
@@ -125,6 +125,9 @@
 const char MILLISECONDS_IN_TIMESTAMP[] = "MillisecondsInTimeStamp";
 const char HTTP_ACCEPT_PORT[] = "HttpAcceptPort";
 const char PERSIST_MESSAGES[] = "PersistMessages";
+const char ENABLE_EXPECTED_NEXT_SEQ_NUM_ON_LOGON[] = "EnableExpectedNextSeqNumOnLogon";
+const char IGNORE_START_END_DAY_TIME[] = "IgnoreStartEndDayTime";
+const char USE_EXTERNAL_SCHEDULER[] = "UseExternalScheduler";
 
 /// Container for setting dictionaries mapped to sessions.
 class SessionSettings
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/SessionState.h quickfix/src/C++/SessionState.h
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/SessionState.h	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/SessionState.h	2015-09-29 14:44:46.428223567 +0000
@@ -45,6 +45,7 @@
   m_sentReset( false ), m_receivedReset( false ),
   m_initiate( false ), m_logonTimeout( 10 ), 
   m_logoutTimeout( 2 ), m_testRequest( 0 ),
+  m_lastExpectedLogonNextSeqNum( 0 ),
   m_pStore( 0 ), m_pLog( 0 ) {}
 
   bool enabled() const { return m_enabled; }
@@ -193,6 +194,19 @@
   void refresh() throw ( IOException )
   { Locker l( m_mutex ); m_pStore->refresh(); }
 
+  void setResetRangeFromLastExpectedLogonNextSeqNumLogon()
+  { 
+    Locker l( m_mutex );
+    resendRange(getLastExpectedLogonNextSeqNum(), 0);
+    setLastExpectedLogonNextSeqNum(0); 
+  }
+  void setLastExpectedLogonNextSeqNum(int lastExpectedLogonNextSeqNum)
+  { Locker l( m_mutex ); m_lastExpectedLogonNextSeqNum = lastExpectedLogonNextSeqNum; }
+  int getLastExpectedLogonNextSeqNum()
+  { Locker l( m_mutex ); return m_lastExpectedLogonNextSeqNum; }
+  bool expectedLogonNextSeqNumSent()
+  { Locker l( m_mutex ); return m_lastExpectedLogonNextSeqNum != 0; }
+
   void clear()
   { if ( !m_pLog ) return ; Locker l( m_mutex ); m_pLog->clear(); }
   void backup()
@@ -215,6 +229,7 @@
   int m_logonTimeout;
   int m_logoutTimeout;
   int m_testRequest;
+  int m_lastExpectedLogonNextSeqNum;
   ResendRange m_resendRange;
   HeartBtInt m_heartBtInt;
   UtcTimeStamp m_lastSentTime;
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/test/SessionTestCase.cpp quickfix/src/C++/test/SessionTestCase.cpp
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/test/SessionTestCase.cpp	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/test/SessionTestCase.cpp	2015-09-29 14:44:46.428223567 +0000
@@ -615,7 +615,7 @@
 TEST_FIXTURE(sessionFixture, doesSessionExist)
 {
   DataDictionaryProvider provider;
-  provider.addTransportDataDictionary( BeginString("FIX.4.2"), std::shared_ptr<DataDictionary>(new DataDictionary()) );
+  provider.addTransportDataDictionary( BeginString("FIX.4.2"), ptr::shared_ptr<DataDictionary>(new DataDictionary()) );
 
   Session * pSession1 = new Session
     ( *this, factory, SessionID( BeginString( "FIX.4.2" ),
@@ -686,7 +686,7 @@
 TEST_FIXTURE(sessionFixture, lookupSession)
 {
   DataDictionaryProvider provider;
-  provider.addTransportDataDictionary( BeginString("FIX.4.2"), std::shared_ptr<DataDictionary>(new DataDictionary()) );
+  provider.addTransportDataDictionary( BeginString("FIX.4.2"), ptr::shared_ptr<DataDictionary>(new DataDictionary()) );
 
   Session* pSession1 = new Session
     ( *this, factory, SessionID( BeginString( "FIX.4.2" ),
@@ -741,7 +741,7 @@
 TEST_FIXTURE(sessionFixture, registerSession)
 {
   DataDictionaryProvider provider;
-  provider.addTransportDataDictionary( BeginString("FIX.4.2"), std::shared_ptr<DataDictionary>(new DataDictionary()) );
+  provider.addTransportDataDictionary( BeginString("FIX.4.2"), ptr::shared_ptr<DataDictionary>(new DataDictionary()) );
 
   Session* pSession = new Session
     ( *this, factory, SessionID( BeginString( "FIX.4.2" ),
diff -x Makefile.am -x configure.ac -x .gitignore -x '*.m4' -u -w -r quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/Utility.h quickfix/src/C++/Utility.h
--- quickfix-e5216dcd1f30a2741de6fe46207af18a091e39a8/src/C++/Utility.h	2014-09-17 04:01:01.000000000 +0000
+++ quickfix/src/C++/Utility.h	2015-09-29 14:44:46.428223567 +0000
@@ -98,7 +98,11 @@
 #include <cstdlib>
 #include <memory>
 
-#if defined(HAVE_STD_SHARED_PTR)
+
+#if defined(HAVE_BOOST)
+  #include <boost/shared_ptr.hpp>
+  namespace ptr = boost;
+#elif defined(HAVE_STD_SHARED_PTR)
   namespace ptr = std;
 #elif defined(HAVE_STD_TR1_SHARED_PTR)
   #include <tr1/memory>
